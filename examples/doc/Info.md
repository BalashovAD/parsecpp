### 1. Parsecpp
Parsecpp - это комбинаторный парсер со строгой типизацией, разработанный для облегчения создания типизированных парсеров хорошо структурированных данных. Он является более простым в использовании по сравнению с такими инструментами, как yacc, и не требует создания полной грамматики для работы. Среди схожих C++ библиотек можно выделить PEGTL, yacc и Boost.Spirit.

Сферы применения Parsecpp включают:
- Парсинг логов для построения и проверки гипотез: Parsecpp может быть использован для сложного анализа лог-файлов, что невозможно сделать через командную строку и bash.
- Обработка человекочитаемых форматов: Parsecpp подходит для парсинга данных, представленных в человекочитаемом формате, таких как команды или инструкции.
- Быстрое создание парсеров для части сложной грамматики: Parsecpp позволяет создавать парсеры для определенных частей больших и сложных грамматик, например, для JSON с предположением, что поля всегда имеют один и тот же порядок.
- Замена Regexp при определенном формате данных: В случаях, когда формат данных четко определен, Parsecpp может заменить использование Regexp, особенно те, которые работают в possessive mode. 
Поскольку парсер не умеет откатывать конечный автомат, как это делает Regexp, некоторые regex перенести тяжелее, как например `\d*(\d)` (последняя цифра числа).

Разница между Greedy, Possessive, и Lazy mode:
Greedy - поведение по умолчанию, захватывает максимум символов
Lazy - захватывает минимум символов
Possessive - захватывает максимум символов, но никогда не откатывает прогресс
```
A(.*)B - greedy        AxBB -> xB
A(.*?)B - lazy         AxBB -> x
A(.*+)B - possessive   AxBB -> error, так как .* захватит всю строку до конца и никогда не откатит прогресс
```

Плюсы:
- Строгая типизация: 
Благодаря строгой типизации, парсер позволяет писать код, который автоматически проверяется на этапе компиляции.
Проверяются выходящий тип и захватываемые переменные. Это обеспечивает большую надежность и безопасность, а также упрощает процесс разработки. 
Тип парсера и его контекст документирует саму работу парсера.
- Header-only: 
Библиотека представляет собой набор заголовочных файлов, что позволяет быстро и легко подключить ее к вашему проекту без необходимости использования LTO для оптимизации.
Зависимости используется только для тестов и бенчмарков.
Это ускоряет интеграцию и снижает порог вхождения для разработчиков.
- Встроенные заготовки: 
Библиотека включает в себя набор встроенных шаблонов, с помощью которых можно быстро "собрать" свой парсер. 
Это ускоряет разработку и позволяет сосредоточиться на решении конкретных задач, а не на написании кода с нуля.
- Zero-cost abstractions: 
Если парсер не использует определенную функциональность, он не тратит на это ресурсы.
- Отсутствие динамического выделения памяти: 
Библиотека не использует динамическое выделение памяти или позволяет избежать его использования. 
Это упрощает управление памятью и уменьшает вероятность ошибок, связанных с выделением и освобождением памяти,
позволяет не тратить время на выделение памяти в куче.
- Поддержка рекурсии: Это позволяет создавать более сложные и выразительные грамматики для анализа данных.

**Note**: Пока UTF-* поддерживается только как длинные символы, верификации корректности нет. Смотри `core/utf8Test.cpp`

Таким образом, Parsecpp предоставляет разработчикам удобный и мощный инструмент для создания типизированных парсеров, 
который обеспечивает простоту использования, высокую производительность и гибкость в работе с различными структурированными данными.

### 2. Как работают комбинаторы и как построить парсер

Основной принцип комбинаторных парсеров - это возможность скомбинировать один или несколько парсеров в один новый.
Существует 3 базовых комбинации из 2 парсеров.
- Когда мы хотим чтобы исполнился первый, потом второй, но вернули мы только результат второго парсера. 
Для этого есть забывающий слева `>>`.
```
// Parser<A> >> Parser<B> -> Parser<B>
```
- Когда мы хотим чтобы исполнился первый, потом второй, но вернули мы только результат первого парсера. 
Для этого есть забывающий справа `<<`.
```
// Parser<A> << Parser<B> -> Parser<A>
```
- Когда нужно сохранить оба результата
```
// concat :: Parser<A> -> Parser<B> -> Parser<std::tuple<A, B>>
```
- Если первый парсер не смог исполниться, то вернуть результат второго парсера. 
Этот вариант работает только для парсеров одного типа, чтобы результирующий тип был определен. 
Для разных типов пришлось бы вернуть `std::variant<A, B>`.
```
// Parser<A> | Parser<A> -> Parser<A>
```
Пример:
```c++
// Parser<std::tuple<double, int>>
auto parser = spaces() >> concat(number<double>(), charFrom(',') >> number<int>()) << spaces();
// Принимает строки вида "  1.33,7 "
```

Основные преобразования для одного парсера:
```c++
repeat :: Parser<A> -> Parser<std::vector<A>>
maybe :: Parser<A> -> Parser<std::optional<A>>
Parser<A> >>= (A -> B) -> Parser<B>
```

### 3. Рекурсия и type erasure

Работа с рекурсией в парсерах может вызвать следующие проблемы:
- Необходимость зафиксировать тип парсера;
- Требование останавливать раскрутку при создании парсера;
- Необходимость разрешить left recursion и остановить раскрутку при выполнении парсера.


Рассмотрим пример верификации языка "любое количество A, после B":
```c++
static auto constexpr pA = charFrom('A');
static auto constexpr pB = charFrom('B');
```

Наиваная реализация:
```c++
auto makeA() {
	return makeA() >> (pA | pB);
}

```
Здесь сразу видны все три проблемы. 
Во-первых, auto не работает с рекурсией когда она не раскручивается, 
а определение типа самостоятельно невозможно, 
так как полный тип парсера `a >> b` зависит от обоих аргументов `Parser<B, CtxA & CtxB, FnType(a >> b)>`. 
Во-вторых, такая рекурсия не имеет остановки. 
В-третьих, это left recursion, на которой parsecpp зациклится.

Как исправить:
1. Сделать тип независимым от внутренней функции парсера. 
Для этого используется метод `toCommonType`, который приводит все парсеры с одним возвращаемым значением (и контекстом) к одному типу, 
производя type erasure.
2. Обернуть рекурсивный вызов в `lazy()` метод, который будет вызывать метод только тогда, когда он потребуется.
3. Перенести рекурсивный вызов в конец, чтобы перед его вызовом мы поглощали часть входной строки. 
В данном случае это тривиально, в более сложных примерах есть обобщенный механизм Removing left recursion.

Исправленная версия:
```c++
Parser<char> makeA() {
    return (pB | (pA >> lazy(makeA))).toCommonType();
}
```

#### `Lazy`

Метод `lazy` принимает генератор парсеров и будет их конструировать по необходимости во время продвижения по строке. 
Так как создание парсеров требует дополнительных затрат, 
такой подход замедляет работу парсера в момент выполнения. 
Однако это самый универсальный метод, который не имеет ограничений.

#### `LazyCached`
Оптимизированный метод - `lazyCached`, который один раз сохранит в себе результат, а дальше будет его переиспользовать. 
Поскольку физически это будет один и тот же объект, все внутренние состояния будут переиспользоваться. 
То есть для корректной работы парсера он не должен иметь mutable переменных. 
Это одна из причин, почему метод apply помечен как const, а `lazyCached` принимает генератор с интерфейсом `Parser<T>(void)`. 
А для работы с внешними состояниями нужно использовать `Context`. Все стандартные парсеры могу быть вызваны через `lazyCached`.

#### Пример
Более сложный пример рекурсии - [язык правильных скобочных последовательностей](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BA%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C). 
Это символьные последовательности, составленные из алфавита, состоящего из символов, сгруппированных в упорядоченные пары 
(например, типы скобок, графически обозначаемые `(` и `)`, `[` и `]`), 
удовлетворяющие определённым правилам, обеспечивающим последовательную вложенность подпоследовательностей, 
обрамлённых открытой и закрытой скобкой одного типа.

Правильные скобочные последовательности образуют язык Дика и формально определяются следующим образом:
- пустая строка — правильная скобочная последовательность;
- правильная скобочная последовательность, взятая в скобки одного типа — правильная скобочная последовательность;
- правильная скобочная последовательность, к которой приписана слева или справа правильная скобочная последовательность — тоже правильная скобочная последовательность.

Так как в случае проверки принадлежности строки языку нам не важен результат парсера, важно только отсутствие ошибки, 
парсер будет иметь тип Parser<Unit>. 
Где `Unit` более функциональный аналог `void`, который также имеет только одно значение, 
но в отличие от `void` поддерживает `operator==` и его можно использовать в шаблонах без выделения особого случая.
```c++
bool checkBraces(std::tuple<char, char> const& cc) noexcept {
    return details::cmpAnyOf(cc
             , std::make_tuple('(', ')')
             , std::make_tuple('{', '}')
             , std::make_tuple('[', ']'));
}

static constexpr auto openBraces = charFrom('(', '{', '[');
static constexpr auto closeBraces = charFrom(')', '}', ']');

Parser<Unit> bracesLazy() noexcept {
    return (concat(openBraces, lazy(bracesLazy) >> closeBraces)
        .cond(checkBraces).repeat() >> success()).toCommonType();
}
```

### 4. Removing Left recursion

#### Математическое выражение с `+-*/`
Для решения задачи распарсить математическое выражение в AST, мы можем воспользоваться [алгоритмом](https://en.wikipedia.org/wiki/Left_recursion#Removing_left_recursion), 
который убирает левую рекурсию из грамматики.
Рассмотрим стандартное определение грамматики математического выражения c левой рекурсией:
```
E -> E Op E | F
F -> NUMBER | ( E )
Op -> + | - | * | /
```
В этом определении есть левая рекурсия и есть реализовать такую схему явно, программа закциклится на `E`. 
Есть универсальный механизм убирания левой рекурсии через ввод дополнительной сущности.
Для не терминала `A`, который определяется правилом с левой рекурсией, 
где `x` не пустая последовательность, то есть поглощает строку при исполнении; 
`y` - не пустая последовательность, которая не начинается с `A`.
```
A -> A x | ... | A x' | y | ... | y'
```
Тогда разбиваем A на два правила:
```
A -> y A' | ... | y' A'
A' -> x A' | ... | x' A' | eps
```
Где `eps` это пустой терминал который не поглощает строку и всегда успешен.

Перепишем грамматику для математического выражения:
```
T -> F T'
T' -> Op F T' | eps
F -> NUMBER | ( T )
```
Но такая реализация не учитывает что операторы `*`, `/` имеет приоритет выше чем `+`, `-`. 
Чтобы это исправить можно ввести дополнительное правило, 
которое будет сначала проваливаться в правила с операторами высокого приоритета, а только потом во все остальные.
```
E -> T E'
E' -> OpLow T E' | eps
T -> F T'
T' -> OpHigh F T' | eps
F -> NUMBER | ( E )
```
Тогда для выражения `1 + 2 * 3` раскроем `E` подставляя только первые вхождения, так как в нашей формуле мы не зайдем дальше. 
Получится последовательность `F (OpHigh F T' | eps) (OpLow F (OpHigh F (OpHigh F T' | eps) | eps) E' | eps)`, 
результирующий проход: `1 eps (+ 2 (* 3 eps eps))`, который будет сворачиваться с конца.


Для реализации парсера математических выражений с использованием библиотеки parsecpp, 
начнем с определения класса, который будет хранить выражение. 
Класс должен включать древовидную структуру для представления выражений.
```c++
struct Expr {
	using ptr = shared_ptr<Expr>;
	using Op = char;

	Expr(double); 
	Expr(ptr, Op, ptr);
	
	ptr m_spLeft;
	ptr m_spRight;
	Op m_op;
    double m_value;
}
```
В качестве операции `smthg | eps` нужно использовать более удобный метод `smthg.maybe()`, 
который превращает парсер в опциональный и имеет тот же смысл: `maybe :: Parser<T> -> Parser<optional<T>>`.  
Оператор `|`, позволяющий выбирать между двумя парсерами, работает только с одним типом, поэтому для `NUMBER | (E)`, 
их нужно будет заранее преобразовать в `Expr`.
Чтобы уменьшить количество forward declaration, предлагается объявлять парсеры в обратном порядке, 
отличном от традиционного порядка в математической нотации.

Воспользовавшись этим подходом, обновленный парсер будет выглядеть следующим образом:
```c++
struct MakeExpr {
    Expr::ptr operator()(
            Expr::ptr const& spLhs,
            std::optional<std::tuple<Expr::Op, Expr::ptr>> const& maybeRhs) const noexcept {
        if (!maybeRhs) {
            return spLhs;
        } else {
            return Expr::make(spLhs, std::get<0>(*maybeRhs), std::get<1>(*maybeRhs));
        }
    }

    Expr::ptr operator()(double n) const noexcept;
};


Parser<Expr::ptr> makeF() noexcept {
    return ((number<double>() >>= MakeExpr{}) | (charFrom('(') >> lazy(makeE) << charFrom(')'))).toCommonType();
}

Parser<std::optional<std::tuple<Expr::Op, Expr::ptr>>> makeT1() noexcept {
    return concat(
            opHigh,
            liftM(MakeExpr{}, makeF(), lazy(makeT1))
    ).maybe().toCommonType();
}

auto makeT() noexcept {
    return liftM(MakeExpr{}, makeF(), makeT1());
}

Parser<std::optional<std::tuple<Expr::Op, Expr::ptr>>> makeE1() noexcept {
    return concat(
            opLow
            liftM(MakeExpr{}, makeT(), lazy(makeE1))
    ).maybe().toCommonType();
}

ParserExpr makeE() noexcept {
    return liftM(MakeExpr{}, makeT(), makeE1()).toCommonType();
}
```

Полную реализацию можно найти в `examples/calc`.

### 5. Context

Иногда парсер должен учитывать определенные динамические параметры или иметь доступ к глобальным переменным. 
Например:
- Возвращаемые парсером объекты мы хотим создавать с помощью специального аллокатора;
- Мы хотим добавить в парсер проверки, которые зависят от текущего состояния системы. 
Например, мы парсим не все сообщения в массиве, а только "новые", начиная с некоторого id;
- Мы хотим создать универсальный парсер, который потом можно специализировать, 
добавив параметры, такие как имя пользователя, границы сообщения и т.д.

Один из способов реализовать это - захватывать переменные по ссылкам или указателям и сохранять их внутри лямбда-функций парсера. 
Однако в этом случае мы должны сами следить за временем жизни переменных, 
а парсер может получить неожиданные побочные эффекты, которые невозможно предсказать по его типу. 
Более элегантный способ - использовать `Context`. 
На момент создания парсера необходимо указать, что ему требуется определенный тип переменной. 
И `operator()` должен поддерживать тип `Stream&, Ctx&`, где Ctx - это `ContextWrapper<T>`, если переменная одна, 
и шаблон, если переменных больше.

Пример:
```c++
template <typename T, typename Allocator>
struct MakeWithAllocator {
	using Ctx = ContextWrapper<Allocator&>;
	
	template <typename ...Args>
	decltype(auto) operator()(Args &&...args, Ctx& ctx) const {
		// ctx.get() is Allocator&
		return ctx.get().alloc<T>(std::forward<Args>(args)...);
	}
}

struct MyClass {
	MyClass(double, double);
};
struct MyAllocator {
	template <typename ...Args>
	Ptr alloc(Args &&...args);
};

auto parser = liftM(MakeWithAllocator<MyClass, MyAllocator>{}, number(), charFrom(' ') >> number());

// usage
MyAllocator myAllocator;
ContextWrapper<MyAllocator&> ctx{myAllocator};
// or 
auto ctx = parser.makeCtx(myAllocator);
parser(stream, ctx);
```
В этом примере мы создаем шаблон `MakeWithAllocator`, который использует аллокатор, 
переданный через `Context`, для создания экземпляра класса `MyClass`. 
Таким образом, мы сохраняем контекст и управляем временем жизни переменных, делая код более безопасным и предсказуемым.

Всего есть четыре способа передать парсеру значение через контект.
- передача по константной ссылке: `ContextWrapper<T const&>`.
  Этот способ подходит для больших объектов, которые требуются только для чтения. 
Например, в строке может быть ошибка, представленная номером кода, а преобразование этой ошибки в более удобное представление может меняться. 
В этом случае можно захватить в контекст `map<int, MyError>`.
- передача по ссылке. `ContextWrapper<T&>`
  Этот способ подходит для больших объектов, таких как аллокаторы. 
Основная опасность такой передачи - откат парсера, который не будет откатывать изменения в захваченном объекте.

```c++
auto parser = (charFrom('a') << hitCounter() << charFrom('c')).repeat();
ContextWrapper<HitCounterType<>> ctx{};
Stream s{"acab"};
parser(s, ctx); // parse only once, remaining string is "ab"
assert(ctx.get() == 2); // no rollback when repeat failed
```
- передача по константному значению: `ContextWrapper<T const>`. 
Обычно используется для небольших переменных с коротким временем жизни, которые будут создаваться в самом `ContextWrapper`. 
То есть они будут создаваться перед исполнением парсера и уничтожаться в той же области видимости. 
Например, случайно сгенерированный guard для определения конца данных.
- передача по значению `ContextWrapper<T>`. 
Обычно этот способ подходит для случаев, когда необходимо проводить отладку или подсчитывать дополнительные метрики, 
которые сложно включить в результирующий тип. 
Например, `DebugContext` работает таким образом: 
он собирает дополнительную информацию в процессе выполнения даже в тех ветках где парсинг закончился ошибкой, 
но не влияет на тип результата.

Контекст парсера автоматически распространяется вверх по вложенности. 
Это означает, что при комбинировании парсеров 
`Parser<X, ContextWrapper<Ctx1>> op Parser<Y, ContextWrapper<Ctx2>>` будет иметь конкест `ContextWrapper<Ctx1, Ctx2>`, 
где порядок важен и влияет на конструктор `ContextWrapper`.

Это свойство контекста позволяет упростить работу с набором парсеров, каждый из которых имеет свой контекст. 
Вместо явного указания контекста для каждой комбинации, контексты автоматически сливаются при комбинировании парсеров. 
Таким образом, вы можете легко создавать сложные парсеры с различными контекстами и быть уверены, 
что все контексты будут корректно учтены в процессе разбора данных.

### 6. Как писать быстрые парсеры.

a) Создание парсера может занимать время, которое мы обычно не хотим тратить во время его исполнения. 
Поэтому лучше всегда выносить создание парсера в некоторый конструктор или брать его из статической переменной. 
Чтобы хранить парсер в классе, нужно либо использовать `decltype(makeParser()) m_parser;`, 
но тогда `makeParser()` должен быть виден и реализован в области видимости объявления. 
Либо использовать type erasure через `toCommonType`. Тогда формат будет вида `Parser<MyType> m_parser;` или `Parser<MyType, MyCtx> m_parser;`.

b) Использовать чистые типы парсера как можно дольше. 
Type erasure всегда замедляет исполнение, так как использует виртуальную функцию и память из кучи. 
Поэтому для парсеров, которые могут вызываться много раз и должны работать быстро, используйте чистые типы. 
Все встроенные парсеры написаны в чистых типах.

с) Рекурсия может быть реализована через 3 метода: `lazy`, `lazyCached`, `lazyForget`, `bracesCtx`. 
Первый самый универсальный, но работает медленно, так как создает новые парсеры во время выполнения и использует type erasure. 
`lazyCached` тоже использует type erasure через `std::function`, но создает парсер один раз. 
`lazyForget` использует более сложный способ стирания типа, что делает его немного быстрее(не всегда), чем `lazyCached`.
`bracesCtx` удобный способ, который позволяет делать более сложные рекурсивные парсеры.
Примеры использования в `benchmark/lazyBenchmark.cpp`.

d) `repeat()`: этот метод сохраняет элементы в std::vector, то есть в данном случае используется динамическое выделение памяти. 
Первый способ ускорить парсер - это задать шаблонный параметр `reserve`, 
особенно если есть предположение о количестве элементов, которые надо распарсить. 
Второй способ - это выбрать более подходящий класс для хранения, например обрабатывать данные в потоке, не сохраняя их.
```c++
auto binanceTradesJson = binanceTrades.repeat<1000>(); // API should return the last 1000 trades

struct CountSumRepeat : public Repeat<CountSumRepeat, double, VoidContext> {
    void add(Container& sum, std::tuple<double, double> priceAndQty) const noexcept {
        sum += get<0>(priceAndQty) * get<1>(priceAndQty);
    }
};

auto sum = concat(number(), charFrom(',') >> number() << spaces()) * CountSumRepeat{}; // Parser<double>
// 1,1.3 2.3,2  => 5.9
```

e) Drop. Для некоторых парсеров (или части составного парсера) в возвращаемом значении нет смысла, 
важен только факт, что мы смогли его исполнить. 
Такие парсеры обычно возвращают `Unit` как тип, населенный одним значением. 
Но в случае, если мы преобразуем такой парсер через `.maybe()`, `.repeat()` и т.д., мы получим тип `optional<Unit>`, `vector<Unit>`, 
хотя нам не всегда важно, был ли(сколько раз) парсер исполнен или нет. 
Тогда, чтобы предоставить возможность более агрессивной оптимизации, но которая будет нарушать правила категории, 
используется специальный тип `Drop`. 
Он также имеет только одно значение, но меняет поведение некоторых функций. 
Например, `charFrom('a').drop().repeat()` не выделяет памяти для `vector`.
```c++
charFrom('a').repeat(); // Parser<std::vector<char>>
charFrom('a').drop().repeat(); // Parser<Drop>
```

d) Constexpr. Для некоторых парсеров существуют `constexpr` перегрузки, которые позволяют захватывать строки или символы в compile-time.
Например:
```c++
auto a = lettersFrom(FromRange('a', 'z'), 'A', 'B', 'C'); 
auto b = lettersFrom<FromRange('a', 'z'), 'A', 'B', 'C'>();
// a === b
```
Для строк нужно использовать суффикс `_prs`:
```c++
auto a = searchText("test");
auto b = searchText<"test"_prs>();
```
Constexpr перегрузки работают быстрее, особенно это заметно в случае большого объема комбинаций парсеров или когда фиксированные строки большой длины не и попадают в SSO. 


Сравнение скорости для задачи проверки правильности скобочной последовательности:
| *                          | Success   | Failure   | Speedup   |
|----------------------------|-----------|-----------|-----------|
| bracesLazy                 | 4667ns    | 4451ns    | 0.56x     |
| bracesCached               | 2599ns    | 2447ns    | 1.0x      |
| bracesCacheConstexpr       | 2692ns    | 2535ns    | 0.97x     |
| bracesForget               | 2745ns    | 2591ns    | 0.95x     |
| bracesCtx                  | 2622ns    | 2495ns    | 0.99x     |
| bracesCtxConstexpr         | 2647ns    | 2523ns    | 0.98x     |
| -------------------------- | --------- | --------- | --------- |
| bracesCachedDrop           | 1987ns    | 1904ns    | 1.31x     |
| bracesCacheDropConstexpr   | 1618ns    | 1501ns    | 1.61x     |
| bracesCtxDrop              | 1952ns    | 1856ns    | 1.33x     |
| bracesCtxDropConstexpr     | 1601ns    | 1511ns    | 1.62x     |


### 7. Примеры
a) Распарсить cvs с фиксированным форматом полей в структуру.
```c++
struct Cvs {
	Time ts;
	std::string name;
	std::optional<int> count;
	// ...
}

static constexpr auto parserCvs = liftM(MakeClass<Cvs>{}, parserTime, charFrom(',') >> until(","), charFrom(',') >> number<int>().maybe() << until("\n")).repeat();
```

b) Быстрый парсинг xml/jsom/etc. 
Если мы знаем что сервер присылает поля в строго определенном порядке и нам важна скорость обработки, 
мы можем не выпаршивать формат честно, а попытаться через прямой порядок. 
В случае ошибки всегда можно вернуться к более медленной версии. Например, binance trades:
```c++
auto jsonValueDouble(std::string fieldName) noexcept {
    return searchText("\"" + fieldName + "\":") >> charFrom('"') >> number<double>() << charFrom('"');
}

auto jsonValueUnsigned(std::string fieldName) noexcept {
    return searchText("\"" + fieldName + "\":") >> number<size_t>();
}

struct BinanceTrade {
	size_t id;
	double price;
	double qty;
	size_t time;
	bool isBuyerMaker;
};

auto parser = charFrom('[') >> (charFrom('{') >> liftM(details::MakeClass<BinanceTrade>{},
		jsonValueUnsigned("id"),
		jsonValueDouble("price"),
		jsonValueDouble("qty"),
		jsonValueUnsigned("time"),
		searchText("\"isBuyerMaker\":") >> (literal("true") >> pure(true) | pure(false))
) << searchText("}") << charFrom(',').maybe()).repeat<1000>() << charFrom(']');
```
